#### 4.8 다중 스레드 기법을 사용했을 때 단일 스레드 기법을 사용했을 때보다 성능이 좋지 않은 프로그래밍 사례 2가지를 제시하시오.
->
１. 순차적으로 실행해야 하는 프로그램인 경우, 다중 스레드 환경에서는 스레드의 실행 순서를 보장할 수 없기 때문.
２. shell과 같이 실행 결과를 지속해서 모니터링 해야 하는 프로그램인 경우

#### 4.9 다중 커널 스레드를 사용하여 다중 스레드 프로그램을 만들었을 때 이 프로그램의 성능이 단일 스레드만 사용하는 프로그램에 비해 더 나은 성능을 보이는 경우는 언제인가?
->
 단일 스레딩 환경에서는 한 번에 하나의 일만 처리할 수 있지만, 다중 스레딩 환경에서는 각 처리기에 태스크를 분배해 처리할 수 있으므로 좀 더 효율적이고 빠른 작업 수행이 가능하다.

####　4.10 다음 중 다중 스레드 프로세스의 스레드 사이에 공유되는 프로그램 상태는 무엇인가?
A. 레지스터 값들
B. 힙 메모리
C. 전역 변수들
D. 스택 메모리
->
모든 스레드는 각각의 레지스터 값과 스택을 가지므로 힙 메모리(B)와 전역 변수들(C)을 공유한다.

#### 4.11 다수의 사용자 수준 스레드를 사용하는 다중 스레드 해결책이 단일 처리기 시스템보다 다중 처리기 시스템에서 더 나은 성능을 보일 수 있는가? 여러분의 답에 대한 정당성을 제시하시오.
->
 단일 처리기 시스템에서 다중 스레딩을 사용하더라도 처리기가 하나이기 때문에 결국 한 개의 스레드씩 순차적으로 실행할 수밖에 없다. 하지만 다중 처리기 시스템에서는 각각의 처리기마다 스레드가 동작 가능하므로 단일 처리기 환경보다 빠르게 작업 수행이 가능하다.

#### 4.12 3장에서 Google 의 Chrome 브라우저에 대해서 논의할 때 새로운 웹사이트마다 개별 프로세스에서 연다는 것을 알았다. 만일 새로운 웹사이트를 프로세스 대신에 개별 스레드에서 열었다면 같은 이득을 얻을 수 있을까?
-> 
만약 웹사이트를 개별 스레드에서 열게 되고, 하나의 웹사이트에 오류가 발생해 종료해야 할 상황이 되면 모든 웹사이트를 종료해야 하므로 같은 이득을 얻을 수 없다.

### 4.13 병렬성은 아니지만, 동시 수행성을 가지는 것이 가능한가?
->
가능하다. 빠른 문맥 교환을 수행할 시 사용자는 마치 동시 수행을 하는 것처럼 보인다.

#### 4.14 Amdahl의 법칙을 사용하여 다음 응용 프로그램의 속도 향상을 계산하여라.
1. (a) 8개의 프로세싱 코어 및 (b) 16개의 프로세싱 코어와 40% 병렬 처리
->
(a) : 1 / 0.6 + ((1-0.6) / 8) = 1 / 0.65 = 1.54
(b) : 1 / 0.6 + ((1-0.6) / 16) = 1 / 0.625 = 1.60

2. (a) 2개의 프로세싱 코어 및 (b) 4개의 프로세싱 코어와 67% 병렬 처리
-> 
(a) : 1 / 0.33 + ((1-0.33) / 2) = 1 / 0.665 = 1.5
(b) : 1 / 0.33 + ((1-0.33) / 4) = 1 / 0.4975 = 2.01

3. (a) 4개의 프로세싱 코어 및 (b) 8개의 프로세싱 코어와 90% 병렬 처리
->
(a) : 1 / 0.1 + ((1-0.1) / 4) = 1 / 0.325 = 3.08
(b) : 1 / 0.1 + ((1-0.1) / 8) = 1 / 0.2125 = 4.71

#### 4.15 다음 문제들이 태스크 병렬성 또는 데이터 병렬성을 보이는지 결정하시오.
1. Using a separate thread to generate a thumbnail for each photo in a collection
->

2. 행렬을 병렬로 이동
->

3. 한 스레드가 네트워크에서 읽고 다른 스레드가 네트워크에 쓰는 네트워크 애플리케이션
->

4. 4.5.2에 설명된 fork-join 배열 합계 애플리케이션
->

5. Grand Central Dispatch system
->

#### 4.16 두 개의 이중 코어 처리기는 스케줄 가능한 4개의 처리기를 가지고 있다. CPU-집중응용이 이 시스템에서 실행 중이라고 하자. 모든 입력은 프로그램이 시작할 때 주어지고 반드시 하나의 파일이 열려야 한다. 마찬가지로 모든 출력은 프로그램이 종료되기 전에 수행된다. 프로그램의 결과는 하나의 파일에 모두 기록되어야 한다. 프로그램이 시작해서 종료할 때까지 프로그램은 CPU 집중적이다. 여러분은 이 프로그램을 다중 스레드 화하여 성능을 향상해야 한다. 응용은 일대일 스레드 모델을 사용하며 각 사용자 수준 스레드는 커널 스레드에 사상 된다.
-> 


#### 4.17 다음 코드 세그먼트를 고려하시오.
```
pid_t pid;
pid=fork();
if(pid==0){
    fork();
    thread_create(...);
   }
  fork();
```
(a) 몇 개의 프로세스가 생성되는가?
-> 첫 번째 fork로 인해 부모 프로세스 + 2개의 자식 프로세스 생성
두 번째 fork로 인해 2개의 자식 프로세스가 각각 2개의 자식 프로세스 생성
3 + 4 = 7개의 프로세스 생성

(b) 몇 개의 스레드가 생성되는가?
-> 2개의 프로세스에서 각 1개씩 스레드를 생성하므로 총 2개의 스레드 생성

#### 4.18 4.7.2절에서 설명된 것처럼 Linux는 프로세스와 스레드를 구별하지 않는다. 대신 Linux는 둘을 같은 방법으로 다룬다. clone() 시스템 호출에 전달되는 플래그에 따라 태스크는 프로세스에 더 가깝거나 스레드에 가까울 수 있다. 그러나 Windows와 같은 많은 운영체제는 프로세스와 스레드를 다르게 취급한다. 통상 이러한 시스템들은 프로세스를 위한 자료 구조가 프로세스에 속한 스레드를 가리키는 포인터를 포함하게 하여 이 관계를 표시한다. 커널 안에서 프로세스와 스레드를 모델링하는 이 두 가지 방식을 비교하라.
-> 

#### 4.19 그림 4.16에 보인 프로그램은 Pthreads API를 사용한다. LINE C와 LINE P의 출력은 무엇인가?
```
#include <pthread.h> 
#include <stdio.h>

int value = 0;
void *runner(void *param); /* the thread */

int main(int argc, char *argv[])
{    pid_t pid;
    pthread_t tid; 
    pthread_attr_t attr;
    pid = fork();
    if (pid == 0) { /* child process */ 
        pthread_attr init(&attr);
        pthread_create(&tid,&attr,runner,NULL); 
        pthread_join(tid,NULL);
        printf("CHILD: value = %d",value); /* LINE C */
    }
    else if (pid > 0) { /* parent process */
        wait(NULL);
        printf("PARENT: value = %d",value); /* LINE P */
    }
}

void *runner(void *param) { 
    value = 5;
    pthread_exit(0);
}
```
->
CHILD: value = 5
PARENT: value = 0

#### 4.20 다중 처리기 시스템과 다대다 모델을 사용하여 작성된 다중 스레드 프로그램을 고려하자. 프로그램의 사용자 수준 스레드의 개수가 시스템의 처리기 개수보다 많다고 가정하자. 다음과 같은 시나리오에서 성능 예측을 논의하시오.
-> 

#### 4.21 스레드 취소 사용 불가능 상태로 지정하기 위한 함수 호출과 취소 사용 가능 상태로 지정하기 위한 함수 호출 상태 사이에 수행하기 적합한 두 연산의 예를 제시하시오.
-> 
