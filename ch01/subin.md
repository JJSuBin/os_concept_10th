## [공룡책 1장 연습문제]

#### 1.1 운영체제의 세 가지 주요 목적은 무엇인가? (p4~5)
->   
(1) 사용자가 하드웨어를 쉽게 다룰 수 있는 환경 제공  
(2) 문제 해결을 위한 자원(CPU 시간, 메모리 공간, 저장장치 공간, 입출력 장치 등)이 효율적으로 사용될 수 있도록 관리 => 자원 관리자 역할  
(3) 컴퓨터의 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어 => 제어 프로그램 역할  

#### 1.2 컴퓨팅 하드웨어를 효율적으로 사용하려면 운영체제가 필요하다고 강조하였다. 운영체제가 이 원칙을 버리고 자원을 낭비하는 것이 적절한 때는 언제인가? 그러한 시스템이 실제로 낭비하는 것이 아닌 이유는 무엇인가?
->   
GUI와 같이 사용자와 시스템 간의 상호작용이 우선되어 사용자 관점에서 편의성을 추구하는 경우 CPU 사이클이 낭비될 수 있다. 
GUI 프로그램은 사용자로부터 입력이 있는지 주기적으로 확인한다. 이는 사용자의 응답에 적절한 응답 제공하고, 빠르게 대응하기 위함이므로 자원 낭비가 아닌 요구사항에 따른 적절한 자원 사용으로 보는 것이 적합하다.

#### 1.3 실시간 환경을 위해 운영체제를 작성할 때 프로그래머가 극복해야 하는 주요 어려움은 무엇인가?
->  
실시간 시스템이란 이벤트 발생부터 처리까지의 과정이 미리 제시된 시간을 넘지 않는 시스템을 의미한다. 즉, 프로그램은 실시간 시스템 환경을 제공하는 운영체제를 작성할 경우 각 작업이 제시된 시간 내에 해결되도록 프로그래밍해야 한다. 만약 제한된 시간 내에 작업을 끝내지 못한다면 전체 시스템에 장애가 발생할 가능성이 우려된다.

#### 1.4 운영체제의 다양한 정의를 염두에 두고 운영체제에 웹 브라우저 및 메일 프로그램과 같은 응용 프로그램이 포함되어야 하는지 생각해 보라. 포함 시킨다와 포함 시키지 않는다는 주장 모두의 입장에서 논증하라.
->   
찬성 : 응용 프로그램이 운영체제 내에 포함되어 있다면 응용 프로그램이 운영체제에서 요청하는 서비스 시간을 줄일 수 있으므로 성능 향상이 예상되기 때문에 찬성한다.

반대 : 응용 프로그램을 운영체제 내에 포함하게 된다면 운영체제 자체의 크기가 커지고, 불필요한 보안 문제가 발생할 수 있으므로 반대한다.

#### 1.5. 커널 모드와 사용자 모드의 구별은 기본적인 형태의 보호(보안)로써 어떤 기능을 하는가? (p26~27)
->  
커널 모드와 사용자 모드는 모트 비트를 사용하여 구별함으로써 운영체제를 위하여 실행되는 작업과 사용자를 위해 실행되는 작업을 구별한다.(0이면 커널 모드, 1이면 사용자 모드) 
 그 이유는 잘못된 사용자로부터 운영체제를, 잘못된 사용자 서로를 보호하기 위함이다. 악영향을 끼칠 수 있는 일부 명령을 특권 명령으로 지정해 커널 모드에서만 수행되도록 허용한다. 

#### 1.6 다음 중 특권 명령이어야 하는 명령어는 무엇인가? (p26~28)
 a. 타이머 설정          
 b. 클록 읽기        
 c. 메모리 내용 삭제   
 d. 트랩 명령의 실행     
 e. 인터럽트 끄기     
 f. 장치 상태 테이블의 항목 수정   
 g. 사용자에서 커널 모드로 전환   
 h. I/O 장치 액세스  
->   
 a, c, e, f, h는 특권 명령으로 커널 모드에서만 수행 가능해야 하고, 나머지 b, d, g 경우에는 사용자 모드에서도 동작 가능한 명령이다. 

#### 1.7 일부 초기 컴퓨터는 운영체제를 사용자 작업이나 운영체제 자체에서 수정할 수 없는 메모리 파티션에 배치하여 운영체제를 보호하였다. 이러한 기법에서 발생할 수 있다고 생각되는 두 가지 어려움을 설명하라.
->   
 운영체제에 필요한 데이터가 보호되지 않은 메모리에 저장되거나 통과되어야 하므로 권한이 없는 사용자가 엑세스 할 수 있으며, 운영체제 자체에서 수정할 수 없는 메모리 파티션에 배치되면 유지보수가 어렵다는 문제가 발생한다.

#### 1.8 일부 CPU는 세 개 이상의 작동 모드를 제공한다. 이 다중 모드를 사용할 수 있는 두 가지 경우는 무엇인가? (답지 참고)
->  
대부분의 시스템은 사용자 모드와 커널 모드만 구분하지만 일부 CPU는 여러 모드를 지원한다. 여러 모드를 사용하여 보다 세분화된 보안 정책을 제공할 수 있다. 예를 들어, 사용자 모드와 커널 모드만 구별하는 대신 다른 유형의 사용자 모드를 구별할 수 있다. 같은 그룹에 속한 사용자가 서로의 코드를 실행할 수도 있다. 이 사용자 중 한 명이 코드를 실행하고 있을 때 컴퓨터는 지정된 모드로 들어간다. 머신이 이 모드에 있을 때 그룹의 구성원은 그룹의 다른 사람에게 속한 코드를 실행할 수 있다.

또 다른 가능성은 커널 코드 내에서 다른 구분을 제공하는 것이다. 예를 들어 특정 모드에서는 USB 장치 드라이버를 실행할 수 있다. 이는 USB 장치가 커널 모드로 전환하지 않고도 서비스될 수 있음을 의미하므로 본질적으로 USB 장치 드라이버가 준 사용자/커널에서 실행될 수 있다.

#### 1.9 타이머는 현재 시간을 계산하는 데 사용될 수 있다. 어떻게 계산이 가능한지 간단하게 설명하라. (p28)
->  
타이머는 지정된 시간이 되면 인터럽트를 발생시키기 때문에 얼마나 시간이 지났는지를 계산하여 현재 시간을 알 수 있다.

#### 1.10 캐시가 유용한 두 가지 이유를 제시하라. 어떤 문제를 해결할 수 있는가? 어떤 문제를 야기하는가? 캐시의 크기를 캐싱하는 장치만큼 크게 만들 수 있다면(예: 디스크의 크기와 같은 캐시) 캐시의 용량을 늘린 후 원래 장치를 제거하지 않는 이유는 무엇인가? (p33~34)
->  
 캐시는 서로 다른 속도를 가진 두 장치 사이에 존재해 데이터 교환 시 유용하게 사용할 수 있다. 이렇게 되면 전송 속도가 빠른 장치는 캐시에서 먼저 데이터를 탐색할 수 있기 때문에 전송 속도의 향상을 돕는다. 
 하지만 캐시의 사용으로 인해 캐시 일관성 문제가 발생할 수 있다. 장치의 데이터가 바뀌었음에도 캐시의 데이터가 바뀌지 않았다면 이를 활용한 다른 장치에 데이터 일성을 제공할 수 없게 된다. 이러한 문제를 방지하기 위해 데이터가 갱신된 경우 모든 캐시에 즉각적으로 반영되어야 한다. 

(답지)
캐시의 기억 용량을 충분히 크게 늘린 후 느린 장치를 제거할 수 없는 이유는 캐시는 고속처리를 위해 고속처리 장치 근처의 한정된 공간을 사용할 수 있기에 대체로 매우 작은 공간만을 활용할 수 있으며 이로 인해 기억가능한 용량이 작기에 대용량 캐시를 구현하는 것은 현실적으로 어렵다. 또한 작은 공간에 대용량 고속처리 스토리지(캐시)를 만드는 것은 비용이 매우 비싸기 때문에 현재의 캐시 설계가 주력으로 활용되는 것이다.

#### 1.11 분산 시스템의 클라이언트-서버 시스템과 피어 간 모델의 차이를 설명하라. (p45~46)
->  
클라이언트-서버 시스템은 서버는 서비스 제공 역할, 클라이언트는 서버가 제공하는 서비스를 소비하는 역할로 구분되지만, P2P 모델은 모든 노드가 동등한 역할을 수행하기 때문에 역할의 구분이 존재하지 않는다.

#### 1.12 clustered systems과 multiprocessor systems의 차이점은 무엇인가? 두 대의 기계가 클러스터로 협력하고 높은 수준의 서비스를 제공하려면 무엇이 필요한가?
->  
클러스터 시스템은 네트워크로 연결된 단일 컴퓨터들의 집합을 통해 하나의 작업을 공동으로 처리하는 것을 말한다. 반면에 멀티 프로세서 시스템은 2개 이상의 CPU를 갖는 시스템을 말한다.
두 대의 기계가 클러스터로 협력하고 싶다면 두 기기 모두 네트워크를 통해 연결되어 있어야 하고, 한 기기가 실패한다면 다른 기기가 대체할 수 있어야 한다. 

#### 1.13 데이터베이스를 실행하는 두 개의 노드로 구성된 컴퓨팅 클러스터를 생각해 보아라. 클러스터 시스템이 디스크의 데이터에 대한 액세스를 관리할 수 있는 두 가지 방법을 설명하십시오. 각각의 장단점에 관해 토론해라.
->  
(1) 접근 제어 : 다수의 컴퓨터 중 하나의 컴퓨터만 데이터베이스에 접근을 허용하는 기법을 말한다. 공유하는 소프트웨어 계층에서 모든 접근을 관리, 각 컴퓨터는 승인이 날 때까지 대기해야 하므로 자원 소모 및 성능 하락의 문제가 있지만 데이터베이스의 안정을 보장할 수 있다.  

(2) 잠금 기법 : 컴퓨터가 데이터베이스에 접근시, 데이터베이스가 사용 중이라는 것을 컴퓨터가 직접 명시하는 기법을 말한다. 각 기계가 직접 데이터베이스에 대한 독점적인 접근을 관리하기 때문에 따로 관리 소프트웨어를 실행할 필요가 없다. 따라서 데이터베이스 성능이 접근 제어 방식보다 높고, 데이터베이스 시스템에서 따로 자원을 소모할 필요가 없다. 그러나 각 기계가 잘못된 실행으로 인해 데이터베이스에 대한 잠금을 하지 않으면, 데이터베이스 시스템의 안정성은 크게 하락하게 되는 단점이 있다.

#### 1.14 인터럽트의 목적은 무엇인가? 인터럽트와 트랩은 어떻게 다른가? 트랩은 사용자 프로그램에 의해 의도적으로 생성될 수 있는가? 만약 그렇다면, 어떤 목적으로?
->  
 인터럽트는 CPU가 프로그램을 실행하고 있을 때, I/O 처리 등과 같은 예외상황이 발생하여 처리가 필요한 경우 사용된다.
 트랩은 프로그램 내에서 발생하여 내부 인터럽트라고 하며, 발생 시점이 프로그램의 일정한 지점이기 때문에 동기적이다. 인터럽트는 프로그램 외부 상황(I/O 장치, 디스크 등)에서 발생하며, 발생 시점이 일정하지 않기 때문에 비동기적이다.
 트랩은 사용자 프로그램에 의해 의도적으로 생성될 수 있다. 예시..?

#### 1.15 Explain how the Linux kernel variables HZ and jiffies can be used to determine the number of seconds the system has been running since it was booted.
->  

#### 1.16 CPU의 실행 부하가 증가하는 것을 피하기 위하여 직접 메모리 액세스(DMA) 방식이 고속입출력 장치에 사용된다.
a. 전송을 조율하기 위하여 CPU는 어떻게 장치와 인터페이스 하는가?  
-> CPU가 DMA 제어기에 다양한 정보를 전송함으로써 데이터 전송을 조율한다.

b. CPU는 메모리 연산이 종료되었음을 어떻게 알 수 있는가?  
-> 인터럽트를 발생시켜 CPU에게 연산의 종료를 알린다.

c. DMA가 데이터를 전송하는 동안 CPU는 다른 프로그램을 실행할 수 있다. 이 프로세스는 사용자 프로그램의 실행을 방해하는가? 만일 그렇다면, 어떤 형태의 방해가 발생하는지 설명하시오.
-> DMA와 사용자 프로그램이 동시에 메모리에 접근하기 때문에 속도가 저하된다.

#### 1.17 일부 컴퓨터 시스템은 모드 연산을 하드웨어로 제공하지 않는다. 이러한 컴퓨터에 안전한 운영체제를 구축할 수 있는지를 고려해 보자, 그것의 가능, 불가능 모두에 대한 논거를 제시하시오.
->

#### 1.18 많은 SMP 시스템은 다른 수준의 캐시를 갖는다. 한 수준은 각 처리 코어에 로컬하고 다른 수준은 모든 처리 코어가 공유한다. 왜 캐싱 시스템을 이렇게 설계했는가?
->
한 데이터를 모든 처리 코어가 공유하게 되면 해당 데이터를 변경하는 경우 연결된 모든 코어의 캐시가 갱신되어야 한다. 그렇지 않으면 데이터 일관성을 침해하는 문제가 발생한다. 하지만 모든 캐시의 값을 변경하는 경우 시간이 오래 걸린다. 이를 해결하기 위해 CPU들이 공유하는 중간 캐시를 두고 중간 캐시 값을 변경, 이후 내부 CPU 캐시의 값을 변경하는 과정을 거친다.

#### 1.19 다음 스토리지 시스템의 순위를 가장 느린 것부터 가장 빠른 것까지 매겨라. (p33)
a. Hard-disk drives
b. Registers
c. Optical disk
d. Main memory
e. Nonvolatile memory
f. Magnetic tapes
g. Cache
-> f -> c -> a -> e -> d -> g -> b

#### 1.20 그림1.8에 보인 것과 비슷한 SMP 시스템을 고려해 보자. 메모리에 저장된 데이터가 각 로컬 캐시에서 다른 값을 가질 수 있는지를 예를 들어 그림으로 보여라.
->

#### 1.21 아래와 같은 처리 환경에서 어느 경우 캐시 데이터의 일관성 문제가 발생하는지 예를 들어 설명하시오.
a. 단일 처리기 시스템
-> 단일 처리기 시스템에서는 문제가 발생하지 않는다.

b. 다중 처리기 시스템
-> 다른 프로세스에서 캐시의 데이터에 접근할 수 있으므로 복사본 중 하나의 값이 변경될 경우 복사본이 존재하는 모든 캐시에 변경이 즉각적으로 반영되어야 데이터 일관성을 보장할 수 있다.

c. 분산 시스템
-> 하나의 파일이 다수의 컴퓨터에 복사본으로 존재할 수 있으므로 한 컴퓨터에 데이터가 변경될 경우 모든 복사본에서 갱신되어야 데이터 일관성을 보장할 수 있다.

#### 1.22 한 프로그램이 다른 프로그램이 사용하는 메모리를 변경하는 것을 막기 위하여 사용되는 메모리 보호 기법을 설명하시오.
-> 

#### 1.23 LAN과 WAN 중에서 아래의 환경에 가장 적합한 네트워크 구성은 무엇인가?
a. 대학 캠퍼스의 학생회관
-> LAN

b. 전체 주에 퍼져있는 다수의 대학의 캠퍼스
-> WAN (LAN보다 범위가 더 넓어야 함)

c. 하나의 동네
-> LAN

#### 1.24 휴대용 장치의 운영체제를 설계할 때의 고려 사항을 전통적 PC의 운영체제 설계와 비교하여 설명해 보시오.
->
휴대용 장치와 PC의 가장 큰 차이점은 무선 네트워크의 유무이다. PC 운영체제는 유선 네트워크 용으로 설계되었지만, 휴대용 장치 운영체제는 무선 네트워크를 통한 모바일용으로 설계되었다.

#### 1.25 클라이언트 서버 시스템에 비해 피어 간 시스템의 장점은 무엇인가?
-> 
클라이언트 서버 시스템은 서비스를 요청하는 노드와 서비스를 제공받는 노드의 역할이 구분되어 있지만, P2P 시스템은 모든 노드가 서비스를 제공할 수도, 요청할 수도 있다.
 따라서 P2P 시스템에서는 클라이언트 서버 시스템과 달리 서비스가 분산된 여러 노드에 의해 제공될 수 있어 효율적이다.

#### 1.26 피어간 시스템에 적합한 분산 응용을 다수 설명해 보시오. (p46)
->
1) Napster : 사용자가 서버에 접속하면 PC의 MP3, WMA 등의 파일을 서버에 전송해 이것을 목록화하는 서버 통제형 방식으로 음악 파일만 공유할 수 있다는 단점이 있다.

2) Gnutella : 중앙 집중식 서버를 두지 않고, P2P 파일 공유 네트워크를 구성하기 위한 분산 소프트웨어 프로젝트이다.

3) edonkey : 최초의 파일 분할식 공유 프로그램

#### 1.27 오픈소스 운영체제의 여러 장점과 여러 단점을 열거하시오. 각 측면을 장점 또는 단점이라고 생각할 수 있는 사람들의 유형도 포함시키시오.
->
장점 : 오픈소스 운영체제의 가장 큰 장점은 무료로 사용할 수 있어 개발 비용이 낮아진다는 점이다. 또한, 여러 사람을 거쳐 수정, 개발되었기 때문에 코드의 안정성이 높다. 이러한 장점은 학생들이나 개인 개발자들에게 극대화될 수 있다. 

단점 : 오픈소스 운영체제의 단점은 회사로부터 제공되지 않기 때문에 갑작스러운 오류나 지원이 보장되지 않는다는 점이다. 이러한 단점은 개발자가 아닌 일반 컴퓨터 사용자들에게 단점으로 생각될 수 있다. 


