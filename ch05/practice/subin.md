[공룡책 5장 Practice Problems]

#### 5.1 CPU 스케줄링 알고리즘은 스케줄 된 프로세스의 실행 순서를 결정한다. 하나의 프로세서에서 n개의 프로세스를 스케줄 하면 몇 개의 다른 스케줄이 가능한가? n에 대한 공식을 제시하라.
->
n! = n * n-1 * n-2 * ... * 2 * 1

#### 5.2 선점 스케줄링과 비선점 스케줄링의 차이점을 설명하라.
->
 선점 스케줄링은 타임 슬라이스가 소진되었거나 인터럽트 또는 시스템 호출 종료로 인해 현재 프로세스보다 높은 우선순위의 프로세스가 나타나는 스케줄링으로 현재 프로세스로부터 강제로 CPU를 회수한다. 반면 비선점 스케줄링은 프로세스가 입출력 요구 등으로 CPU를 자진 반납할 때까지 CPU에 의한 실행을 보장해 주는 스케줄링이다. 

#### 5.3 표시된 시간에 다음 프로세스가 도착한다고 가정하자. 각 프로세스는 나열된 시간 동안 실행된다. 질문에 답할 때, 비선점 스케줄링을 사용하고 결정을 해야 할 시점에 가지고 있는 정보를 기초로 결정을 내려야 한다.
|프로세스|도착 시간|버스트 시간|
|:---:|:---:|:---:|
|P1|0.0|8|
|P2|0.4|4|
|P3|1.0|1|

a. FCFS 스케줄링 알고리즘을 사용할 경우 프로세스의 평균 총처리 시간을 얼마인가?  
->
(8 + 11.6 + 12) / 3 = 10.53

b. SJF 스케줄링 알고리즘을 사용할 경우 프로세스의 평균 총처리 시간을 얼마인가?  
->
(8 + 12.6 + 8) / 3 = 9.53

c. SJF 알고리즘은 성능을 향상해야 하지만 두 개의 더 짧은 프로세스가 곧 도착할 것을 알지 못했기 때문에 시간 0에서 프로세스 P1을 실행하기로 선택했다. CPU가 첫 1단위 동안 유휴상태로 유지된 후 SJF 스케줄링이 사용되는 경우 평균 총처리 시간을 계산하라. 이 유휴시간 동안 프로세스 P1 및 P2가 대기 중이므로 대기 시간이 증가할 수 있다. 이 알고리즘은 미래-지식 스케줄링으로 알려져 있다.  
->
(14 + 5.6 + 1) / 3 = 6.86

#### 5.4 CPU 버스트 시간의 길이가 밀리초 단위로 다음과 같은 프로세스 집합을 고려하시오.
|프로세스|버스트 시간|우선순위|
|:---:|:---:|:---:|
|P1|2|2|
|P2|1|1|
|P3|8|4|
|P4|4|2|
|P5|5|3|

프로세스는 모두 시간 0에서 P1, P2, P3, P4, P5 순서로 도착한 것으로 가정한다.

a. FCFS, SJF, 비선점 우선순위(높은 우선순위가 높을수록 우선순위가 높음) 및 RR(양자 = 2)을 사용하여 이러한 프로세스의 실행을 설명하는 4개의 Gantt 차트를 그려라.  
->
FCFS : 0-2(P1), 2-3(P3), 3-11(P3), 11-15(P4), 15-20(P5)  
SJF : 0-1(P2), 1-3(P1), 3-7(P4), 7-12(P5), 12-20(P3)  
비전섬 우선순위 : 0-8(P3), 8-13(P5), 13-15(P1), 15-19(P4), 19-20(P2)  
RR : 0-2(P1), 2-3(P2), 3-5(P3), 5-7(P4), 7-9(P5), 9-11(P3), 11-13(P4), 13-15(P5), 15-17(P3), 17-18(P5), 18-20(P5)  

b. 각 부분에서 각 스케줄링 알고리즘에 대한 각 프로세스의 처리 시간은 얼마인가?
->
||FCFS|SJF|Priority|RR|
|:---:|:---:|:---:|:---:|:---:|
|P1|2|3|15|2|
|P2|3|1|20|3|
|P3|11|20|8|20|
|P4|15|7|19|13|
|P5|20|12|13|18|

c. 이러한 각 스케줄링 알고리즘에 대한 각 프로세스의 대기 시간은 얼마인가?
->
||FCFS|SJF|Priority|RR|
|:---:|:---:|:---:|:---:|:---:|
|P1|0|1|13|0|
|P2|2|0|19|2|
|P3|3|12|0|12|
|P4|11|3|15|9|
|P5|15|7|8|13|

d. 어떤 알고리즘이 최소 평균대기 시간을 보이는가?
->
SJF 스케줄링 알고리즘

#### 5.5 다음 프로세스는 선점형 라운드-로빈 스케줄링 알고리즘을 사용하여 스케줄링 된다.
|프로세스|우선순위|버스트 시간|시간|
|:---:|:---:|:---:|:---:|
|P1|40|20|0|
|P2|30|25|25|
|P3|30|25|30|
|P4|35|15|60|
|P5|5|10|100|
|P6|10|10|105|

각 프로세스에는 숫자 우선순위가 할당되며 숫자가 높을수록 상대적 우선순위가 더 높다. 아래에 나열된 프로세스 외에도 시스템에는 유휴 작업(CPU 자원을 소비하지 않음)이 있다. 이 작업의 우선순위는 0이며 시스템에 실행 가능한 다른 프로세스가 없을 때마다 스케줄 된다. 시간 할당량의 길이는 10단위이다. 프로세스가 우선순위가 높은 프로세스에 의해 선점되면 선점된 프로세스는 큐의 끝에 배치된다.

a. Gantt 차트를 사용하여 프로세스의 스케줄 순서를 보여라.  
->
0-20(P1), 20-25(idle), 25-35(P2), 35-45(P3), 45-55(P2), 55-60(P3), 60-75(P4), 75-80(P2), 80-90(P3), 90-100(idle), 100-105(P5), 105-115(P6), 115-120(P5)

b. 각 프로세스에 소요되는 총처리 시간은 얼마인가?  
->
|프로세스|총처리 시간|
|:---:|:---:|
|P1|20|
|P2|55|
|P3|60|
|P4|15|
|P5|20|
|P6|10|

c. 각 프로세스의 대기 시간은 얼마인가?  
->
|프로세스|대기 시간|
|:---:|:---:|
|P1|0|
|P2|40|
|P3|35|
|P4|0|
|P5|10|
|P6|0|

d. CPU 이용률은 얼마인가?  
->
87.5%

#### 5.6 다단계 큐 시스템에서 단계마다 다른 시간 할당량을 지정하는 것은 어떤 이점이 있는가?
->
다단계 큐 시스템은 프로세스들을 특정 기준에 따라 그룹으로 분류하고, 그룹마다 우선순위를 차등으로 매겨 다단계 큐에 할당하게 된다. 이때 각 다단계 큐의 시간 할당량을 다르게 배분한다면 우선순위가 낮더라도 자주 요구되는 프로세스 집합을 빈번하게 대기열에 올릴 수 있으므로 시스템의 효율을 증대시킬 수 있다. 

#### 5.7 많은 CPU 스케줄링 알고리즘이 매개변수화 된다. 예를 들어 RR 알고리즘에는 타임 슬라이스를 나타내는 매개변수가 필요하다. 다단계 피드백 큐에는 큐의 수, 각 큐의 스케줄링 알고리즘, 큐 간 프로세스 이주에 사용되는 기준 등을 정의하는 매개변수가 필요하다. 따라서 이러한 알고리즘은 실제로는 알고리즘 집합이다. 한 알고리즘 집합은 다른 집합을 포함할 수 있다. 다음 알고리즘 집합 쌍 사이에는 어떤 관계가 있는가?

a. 우선순위 및 SJF
-> 버스트 시간이 짧은 프로세스일수록 높은 우선순위를 갖는다.

b. 다단계 피드백 큐 및 FCFS
-> The lowest level of MLFQ is FCFS.

c. 우선순위 및 FCFS
-> 가장 오랫동안 존재했던 프로세스에 높은 우선순위를 부여한다.

d. RR과 SJF
-> 없다.

#### 5.8 CPU 스케줄링 알고리즘이 최근 과거에 가장 적은 프로세서 시간을 사용한 프로세스를 선호한다고 가정한다. 이 알고리즘이 I/O 중심 프로그램을 선호하지만 CPU 중심 프로그램을 영구적인 기아 상태로 만들지 않는 이유는 무엇인가?
->

#### 5.9 PCS와 SCS 스케줄링을 구별하라.
->
 PCS 스케줄링은 같은 프로세스 내에 존재하는 스레드끼리 경쟁 상태에 놓이게 된다. 반면 SCS 스케줄링은 시스템에 존재하는 모든 스레드끼리 경쟁 상태에 놓이게 된다. 

#### 5.10 전통적인 UNIX 스케줄러는 우선순위 번호와 우선순위 사이에 반비례 관계를 강제한다. 숫자가 높을수록 우선순위가 낮다. 스케줄러는 일 초마다 다음 수식을 사용하여 프로세스 우선순위를 다시 계산한다. Priority = (recent CPU usage / 2) + base 여기서 base = 60이고, recent CPU usage는 우선순위가 마지막으로 다시 계산된 이후 프로세스가 CPU를 사용한 빈도를 나타내는 값이다. 프로세스 P1의 최근 CPU 사용량이 40이고 프로세스 P2의 경우 18, 프로세스 P3의 경우 10이라고 가정한다. 우선순위를 다시 계산할 때 이 세 프로세스의 새로운 우선순위는 무엇인가? 이 정보를 기반으로 판단했을 때 전통적인 UNIX 스케줄러가 CPU 중심 프로세스의 상대적 우선순위를 올리는가 아니면 내리는가?
->
각 우선순위는 P1이 80, P2가 69, P3가 65이다. 따라서 스케줄러는 CPU 중심 프로세스의 상대적 우선순위를 낮춰야 한다.
