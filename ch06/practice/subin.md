### [공룡책 6장 연습문제]

#### 6.1 6.4절에서 인터럽트를 자주 비활성화하면 시스템 클록에 영향을 줄 수 있다고 언급했다. 왜 이런 일이 발생할 수 있고 그러한 영향을 최소화하는 방법에 관해 설명하라.
-> 
 시스템 클록은 인터럽트가 발생할 때마다 갱신되면서 최신값을 유지한다. 인터럽트가 자주 비활성화되면 시스템 클록은 정확한 값을 가질 수 없게 된다. 이러한 시스템 클록 값은 프로세스 스케줄링 과정에서 사용되기 때문에 해당 과정에 문제가 발생할 수 있다. 이러한 문제가 발생하지 않도록 짧은 간격으로 클럭 인터럽트를 비활성화하여 이러한 문제를 최소화할 수 있다.

#### 6.2 바쁜대기라는 용어의 의미는 무엇인가? 운영체제에는 어떤 다른 대기가 있는가? 바쁜 대기를 완전히 피할 수 있는가?
->
바쁜대기란 한 프로세스가 임계구역에 있을 때 다른 프로세스들은 임계구역에 있는 프로세스가 작업을 끝낼 때 따지 계속 확인하며 무한 루프를 돌며 대기하는 것을 말한다. 운영체제의 다른 대기 종류는 아래와 같다.
1. 제한된 대기 : 일정한 시간 내에 프로세스가 작업을 실행할 수 있는 상태(dispatch)가 되어야 한다는 조건
2. 무한 대기 : 상대방 프로세스의 상태를 모르고 실행을 멈추고 계속하여 기다리고 있는 상태
3. 점유 및 대기 : 실행하는데 필요한 자원을 일부만을 할당 받고 일부는 요청하고 있는 상태
4. 환형 대기 : 자원할당 그래프를 그려 할당과 요청의 상태를 보았을 때 환형(cycle)의 그림이 보이는 상태  

바쁜대기를 피하는 방법으로는 대기 프로세스를 중지시키고 조건을 충족할 시에 프로세스를 다시 깨우는 방식이 있지만, 이러한 방법은 무한정 기다리는 방식보다 더 많은 오버헤드를 초래한다. 

#### 6.3 스핀락이 단일 프로세서 시스템에 적합하지 않지만 다중 처리기 시스템에서는 종종 사용되는 이유를 설명하라.
->
스핀락을 가진 프로세스가 스스로 락을 포기해야 다른 프로세스의 실행이 가능하다. 만약 단일 프로세서 시스템에서 스핀락이 걸리면 시스템이 봉쇄되는 문제가 발생할 수 있기 때문에 적합하지 않다.

#### 6.4 wait() 및 signal() 세마포 연산이 원자적으로 실행되지 않으면 상호 배제가 위반될 수 있음을 보여라.
->
 두 개의 세마포어 연산이 원자적으로 실행되지 않으면 두 연산이 모두 세마포어 값을 감소시키기 때문에 상호 배제를 위반한다.

#### 6.5 이진 세마포를 사용하여 n개의 프로세스 간에 상호 배제를 구현하는 방법을 설명하라.
->

  ```
  do {
  wait(mutex);

    /* critical section */

  signal(mutex);

    /* remainder section */
    } while (true);
   ``` 

#### 6.6 경쟁 조건을 많은 컴퓨터 시스템에서 가능하다. deposit(amount)와 withdraw(amount)의 두 가지 함수를 사용하여 계좌 잔고를 유지하는 은행 시스템을 고려해보자. 이 두 함수는 은행 계좌 잔고에서 예치 또는 인출될 금액을 인자로 전달받는다. 남편과 아내가 은행 계좌를 공유한다고 가정하자. 남편은 withdraw() 함수를 호출하고 아내는 deposit() 함수를 병행하게 호출한다. 어떻게 경쟁 조건이 발생할 수 있는지 설명하고 경쟁 조건이 발생하지 않도록 하려면 무엇을 해야 하는지 설명하라.
->
 남편과 아내는 같은 은행 계좌를 공유하고 있으므로 동일한 값을 변경시키는 연산을 병행하게 수행하게 되면 문제가 발생한다. 이는 상호 배제를 위반하는 경우로 하나의 연산이 끝날 때까지 계좌 잔고를 변경하는 다른 연산은 수행할 수 없도록 해야 한다. 