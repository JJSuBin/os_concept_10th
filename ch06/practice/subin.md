### [공룡책 6장 연습문제]

#### 6.1 6.4절에서 인터럽트를 자주 비활성화하면 시스템 클록에 영향을 줄 수 있다고 언급했다. 왜 이런 일이 발생할 수 있고 그러한 영향을 최소화하는 방법에 관해 설명하라.
-> 
 시스템 클록은 인터럽트가 발생할 때마다 갱신되면서 최신값을 유지한다. 인터럽트가 자주 비활성화되면 시스템 클록은 정확한 값을 가질 수 없게 된다. 이러한 시스템 클록 값은 프로세스 스케줄링 과정에서 사용되기 때문에 해당 과정에 문제가 발생할 수 있다. 이러한 문제가 발생하지 않도록 짧은 간격으로 클럭 인터럽트를 비활성화하여 이러한 문제를 최소화할 수 있다.

#### 6.2 바쁜대기라는 용어의 의미는 무엇인가? 운영체제에는 어떤 다른 대기가 있는가? 바쁜 대기를 완전히 피할 수 있는가?
->
바쁜대기란 한 프로세스가 임계구역에 있을 때 다른 프로세스들은 임계구역에 있는 프로세스가 작업을 끝낼 때 따지 계속 확인하며 무한 루프를 돌며 대기하는 것을 말한다. 이러한 바쁜대기를 피하는 방법으로는 대기 프로세스를 중지시키고 조건을 충족할 시에 프로세스를 다시 깨우는 방식이 있다.

#### 6.3 스핀락이 단일 프로세서 시스템에 적합하지 않지만 다중 처리기 시스템에서는 종종 사용되는 이유를 설명하라.
->
스핀락을 가진 프로세스가 스스로 락을 포기해야 다른 프로세스의 실행이 가능하다. 만약 단일 프로세서 시스템에서 스핀락이 걸리면 시스템이 봉쇄되는 문제가 발생할 수 있기 때문에 적합하지 않다.

#### 6.4 wait() 및 signal() 세마포 연산이 원자적으로 실행되지 않으면 상호 배제가 위반될 수 있음을 보여라.
->
 wait과 signal 연산은 프로세스들이 공유하는 변수 count의 값을 증감하는 과정을 수행한다. 이때 한 프로세스가 count 값을 변경하고 있는 중간에 다른 프로세스가 wait 또는 signal 연산을 수행한다면 두 프로세스가 동시에 하나의 값을 변경하는 경우가 생기므로 상보 배제가 위반된다. 
+ wait 연산과 signal 연산에서 count 값은 실제 자원을 말하는 것이 아닌 사용할 수 있는 자원의 개수 그 자체를 의미한다. 
+ 상호 배제가 위반되면 count의 값과 실제 자원의 수와 맞지 않아 count의 값보다 프로세스가 많아지는(더 문제)/적어지는 경우가 발생한다. count의 값보다 프로세스가 적어지는 경우는 큰 문제가 발생하지 않지만, 그 반대의 경우 하나의 자원에 여러 프로세스가 할당되는 문제가 발생할 수 있다.

#### 6.5 이진 세마포를 사용하여 n개의 프로세스 간에 상호 배제를 구현하는 방법을 설명하라.
->

  ```
  do {
  wait(mutex);

    /* critical section */

  signal(mutex);

    /* remainder section */
    } while (true);
   ``` 

#### 6.6 경쟁 조건을 많은 컴퓨터 시스템에서 가능하다. deposit(amount)와 withdraw(amount)의 두 가지 함수를 사용하여 계좌 잔고를 유지하는 은행 시스템을 고려해보자. 이 두 함수는 은행 계좌 잔고에서 예치 또는 인출될 금액을 인자로 전달받는다. 남편과 아내가 은행 계좌를 공유한다고 가정하자. 남편은 withdraw() 함수를 호출하고 아내는 deposit() 함수를 병행하게 호출한다. 어떻게 경쟁 조건이 발생할 수 있는지 설명하고 경쟁 조건이 발생하지 않도록 하려면 무엇을 해야 하는지 설명하라.
->
 남편과 아내는 같은 은행 계좌를 공유하고 있으므로 동일한 값을 변경시키는 연산을 병행하게 수행하게 되면 문제가 발생한다. 이는 상호 배제를 위반하는 경우로 하나의 연산이 끝날 때까지 계좌 잔고를 변경하는 다른 연산은 수행할 수 없도록 해야 한다. 